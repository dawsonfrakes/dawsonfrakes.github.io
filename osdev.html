<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Adventures in x86_64 OS Development</title>
	<meta name="viewport" content="width=device-width">
	<style>
		span.ident { color: blue }
	</style>
</head>

<body>
	<h1>IN PROGRESS: Adventures in x86_64 OS Development</h1>
	<p>30 Oct 2023 - ?</p>
	<p>I have wanted to create my own OS for a long time. Even before I began hating all the currently available general-purpose operating systems. This article will guide you through every painful thing I figured out along the way.</p>

	<h2>Note for beginners</h2>
	<p>Casey Muratori's <em>Handmade Hero</em> is a wonderful introduction to low-level Windows programming. Casey happily points out all the mistakes that Microsoft have made when developing an OS. He is highly opinionated, but he is always correct (in my opinion). The project begins with a 5 hour intro/review of C, followed by 700+ hours of game engine programming. Each episode (aka "day") is roughly one hour. Days 1-15, 21, and 36 contain the majority of the good stuff useful to people who want to write their projects from scratch<sup>1</sup>, with a higher standard of quality.</p>
	<hr>
	<p>1. We're going lower than that here, C is too high level KEKW</p>

	<h2>Talking to our hardware (TODO: remove duplication)</h2>
	<p>We need to write machine code. What is machine code? Binary digits (bits, 0 and 1) in sequence stored in a manner our machine can find, describing commands we want our hardware to perform. How do we know what bit patterns perform which actions? RTFM! Intel (and AMD) have graciously provided us with 5000+ pages of content we don't want to read, but could if we want to program the hardware we paid for. Fortunately, there's a lot of duplicate information with minor differences created over the evolution of their hardware that we can safely ignore most of the time. 15 opcodes (bit sequences corresponding to actions our CPU is hardwired to perform when it sees them, aka instructions) account for 90% of instructions used in all programs. (TODO: fact-check these magic numbers)</p>
	<p>There are many ways to write binary integers to a location your hardware can read. Back in the 70s you'd feed hole-punched paper into a machine. In the 90s, you flipped switches on the front casing and pushed a button to "enter" the sequence. Nowadays, you can write a script written in Python interpreted by a program written in C which was compiled to x86_64 assembly and packaged with a header your OS could read to know what to load where. This overcomplicated stack of software running between us and our hardware is what started my journey.</p>
	<p>Machine code! It's the only thing our hardware is hardwired to understand. And we need some method of placing the right bits in the right place. In the past, we could have punched holes in paper and fed them to a machine which could interpret the sequence. Slightly less in the past we could have flipped switches directly on the front of our computer and pressed a button to "enter" the sequence. Now we are overwhelmed by how many ways we can program a computer that barely anyone knows what the resulting machine code will look like. This disconnect from the user and their hardware is what prompted me down the path of learning about OSs. Okay, assuming we want to write the instructions our machine will actually execute, how do we do it in modern times? Along with the many ways to program a computer I mentioned, most can be used to generate the machine code we require without the pain of physically flicking switches or hole-punching cards. One option is an assembler such as fasm, the flat assembler, and nasm, the Netwide Assembler. These tools attempt to match the Intel manual's mnemonic as closely as possible to generate near 1-to-1 sequences of instructions (opcodes) to machine code. Assemblers are a nice option, but you're still one level above knowing exactly what machine code is generated when an instruction is assembled. Another option is to use a hex editor and manually type the opcodes you're wanting to use as described in the Intel manual. Instead, I have chosen to implement a simple custom assembler in Python (but any tool which can write binary to files is fine), whose syntax will be easily ported to a self-hosted assembler's syntax when our OS supports it.</p>
	<h2>Read the manual!</h2>
	<p>Nearly all activities in OS development involve reading a manual or scouring the internet for weird sources to understand a piece of hardware enough to talk to it appropriately. Not very glamourous, I know.</p>
	<p>Before we can talk to our computer, we need to know what it can hear from us. Intel have documented this thoroughly. Want to add two numbers together? Find 'add' in the manual, put its opcode and arguments in a file.</p>
	<h2>Booting</h2>
	<p>Okay, but if we haven't written filesystem drivers, what good does a binary file do us? Luckily the hardware engineers have a solution for us. BIOS (older, less standardized) and UEFI (the opposite) are the two common standards an x86_64 computer will attempt to boot with. Ideally standard methods are well documented, and for UEFI that appears to be the case. However, we're starting with BIOS.</p>
	<h2>BIOS</h2>
	<p>The booting process of BIOS is relatively straightforward. It reads the first sector (512 bytes) of each drive attached to the system (in the order set by the user) and if the last two bytes (510, 511) are 0x55 and 0xAA respectively, it will (or, should...) place the drive number in dl (the lower half of the dx register), and load the sector to 0x7c00 in memory.</p>

<h2>What is assembly and is it useful?</h2>
<p>While our computers can only read bits, we humans tend to prefer textual language. Remembering specfic opcodes may be a cool party trick, but it's likely just a waste of time compared to understanding the concepts the opcodes implement, since the manual will remember the architecture-specific bits for us. Assembly is a simple textual mnemonic used to capture the idea of what the CPU is to perform when it sees it.</p>

<h2>Writing an Assembler</h2>
<p>An assembler is a program which takes this human-readable form and converts it into the bit patterns our specific CPU is expecting. Assemblers are entirely unnecessary, but are a convenient way for humans to interpret and write machine code.</p>

<p>Some instructions can be encoded in multiple ways. It's basically up to you which one to choose. <kbd>fasm</kbd> always chooses the smallest size option, for example. They likely each have different tradeoffs, either in size, speed or capability.</p>
<pre>
Format:
What we want &Implies; Intel Manual Syntax &Implies; Specified Output

<code>add <var>ax</var>, 5 &Implies; ADD AX, imm16 &Implies; 0x05 0x0005</code>
<code>add <var>ax</var>, 5 &Implies; ADD r/m16, imm16 &Implies; 0x81 0b11000000 0x0005</code>
<code>add <var>ax</var>, 5 &Implies; ADD r/m16, imm8 &Implies; 0x83 0b11000000 0x05</code>
</pre>

<p>Using <code>objdump</code> to view 16-bit Real Mode output (TODO: check if -D is best)</p>
<kbd>objdump -b binary -m i8086 -Mintel -D <var>file.bin</var></kbd>

<h2>Hexadecimal can help you (and binary literals!)</h2>
<h2>Endianness can mess you up</h2>
<h2>Calling conventions can mess you up</h2>
<h2>Stack size can mess you up</h2>
<h2>Segment Registers can mess you up</h2>

<h2>Two-stage Boot Loader (TODO: explain why)</h2>
<pre>
<kbd>fasm stage2.asm</kbd>
<kbd>fasm -d stage2_size=$(wc -c < stage2.bin) boot.asm</kbd>
</pre>

<p>Clearing interrupts (TODO)</p>

<h2>UEFI</h2>

<h2>Tricks for x86</h2>
<p>Setting a register <var>r</var> to zero can be done by exclusive-or'ing with itself, resulting in less output bytes (TODO: fact-check.)</p>
<code>xor <var>r</var>, <var>r</var> = mov <var>r</var>, 0</code>
</body>

</html>
